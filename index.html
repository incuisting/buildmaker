<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3D</title>
    <style>
        html, body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            font-family: 'Arial', sans-serif;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            touch-action: manipulation;
        }
        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
            -ms-touch-action: none;
        }
        #floorPanel {
            position: absolute;
            top: 20px;
            left: 20px;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 15px;
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);
            max-width: none;
        }
        .floor-btn-container {
            display: flex;
            flex-direction: column;
            margin: 3px;
            background-color: #f5f5f5;
            border-radius: 5px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            width: 100px;
            overflow: hidden;
        }
        .floor-btn {
            display: block;
            padding: 10px 12px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 0;
            cursor: pointer;
            text-align: center;
            width: 100%;
            min-width: 100px;
            font-weight: bold;
            font-size: 15px;
        }
        .floor-btn-actions {
            display: flex;
            width: 100%;
        }
        .delete-btn {
            margin-left: 0;
            padding: 3px 0;
            background-color: #f44336;
            color: white;
            border: none;
            border-radius: 0;
            cursor: pointer;
            font-size: 11px;
            display: none;
            flex: 1;
            text-align: center;
        }
        .lock-btn {
            margin-left: 0;
            padding: 3px 0;
            background-color: #2196F3;
            color: white;
            border: none;
            border-radius: 0;
            cursor: pointer;
            font-size: 11px;
            display: none;
            flex: 1;
            text-align: center;
        }
        .lock-btn.locked {
            background-color: #FF9800;
        }
        .delete-btn:hover {
            background-color: #d32f2f;
        }
        .lock-btn:hover {
            background-color: #0b7dda;
        }
        .lock-btn.locked:hover {
            background-color: #e68a00;
        }
        .floor-btn:hover {
            background-color: #45a049;
        }
        .floor-btn.active {
            background-color: #2E7D32;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
        }
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);
        }
        #heightControls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 15px;
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .direction-controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 2px;
            margin-top: 2px;
        }
        .direction-btn {
            width: 30px;
            height: 30px;
            background-color: #2196F3;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
        }
        .direction-btn:hover {
            background-color: #0b7dda;
        }
        .height-controls {
            display: flex;
            flex-direction: column;
            gap: 4px;
            margin-top: 0;
        }
        .height-btn {
            width: auto;
            padding: 8px 10px;
            background-color: #2196F3;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            text-align: center;
            font-size: 13px;
            font-weight: bold;
        }
        .height-btn:hover {
            background-color: #0b7dda;
        }
        #resetBtn {
            margin-top: 0;
            padding: 4px 6px;
            background-color: #f44336;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            text-align: center;
            width: auto;
            font-size: 11px;
            height: auto;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }
        #resetBtn:hover {
            background-color: #d32f2f;
        }
        /* 删除原有的旋转控制面板样式 */
        /* 新增的摇杆式旋转控制面板样式 */
        #joystickRotationControl {
            width: 180px;
            height: 35px;
            background-color: rgba(255, 255, 255, 0.5);
            border-radius: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: none;
            position: relative;
            flex: 0 0 180px;
            margin: 0 5px;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.1);
            align-self: center;
        }
        #joystickRotationTitle {
            position: absolute;
            top: -20px;
            width: 100%;
            text-align: center;
            font-size: 12px;
            font-weight: bold;
            color: #333;
        }
        #joystickBase {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: rgba(156, 39, 176, 0.2);
        }
        #joystickHandle {
            width: 30px;
            height: 30px;
            background-color: #9C27B0;
            border-radius: 50%;
            position: absolute;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            transition: background-color 0.2s ease, box-shadow 0.2s ease;
        }
        #joystickHandle:hover {
            box-shadow: 0 0 8px rgba(0, 0, 0, 0.5);
        }
        #joystickTip {
            position: absolute;
            bottom: -20px;
            width: 100%;
            text-align: center;
            font-size: 12px;
            color: #666;
            pointer-events: none;
        }
        .panel-section:nth-child(3) {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .panel-section:nth-child(3) h3 {
            margin-bottom: 10px;
        }
        /* 新增的Y轴移动控制面板样式 */
        #yAxisControl {
            position: absolute;
            left: 10px;
            top: 50%;
            transform: translateY(-50%);
            width: 35px;
            height: 180px;
            background-color: rgba(255, 255, 255, 0.8);
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            padding: 8px 0;
        }
        #yAxisSlider {
            width: 100%;
            height: 100%;
            position: relative;
            cursor: ns-resize;
        }
        #yAxisHandle {
            position: absolute;
            left: 5px;
            right: 5px;
            height: 18px;
            background-color: #2196F3;
            border-radius: 3px;
            top: 50%;
            transform: translateY(-50%);
        }
        #yAxisLabel {
            text-align: center;
            font-size: 11px;
            font-weight: bold;
            margin-bottom: 5px;
        }
        /* 新增的缩放控制面板样式 */
        #zoomControl {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            width: 35px;
            height: 180px;
            background-color: rgba(255, 255, 255, 0.8);
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            padding: 8px 0;
        }
        #zoomSlider {
            width: 100%;
            height: 100%;
            position: relative;
            cursor: ns-resize;
        }
        #zoomHandle {
            position: absolute;
            left: 5px;
            right: 5px;
            height: 18px;
            background-color: #FF9800;
            border-radius: 3px;
            top: 50%;
            transform: translateY(-50%);
        }
        #zoomLabel {
            text-align: center;
            font-size: 11px;
            font-weight: bold;
            margin-bottom: 5px;
        }
        .floor-buttons-row {
            display: flex;
            flex-wrap: wrap;
            justify-content: flex-start;
            max-height: 170px;
            overflow-y: auto;
            align-items: center;
            padding: 5px 10px;
            gap: 8px;
        }
        /* 添加新的统一控制面板样式 */
        #unifiedControlPanel {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 10px 10px;
            box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.2);
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: space-between;
            min-height: 120px;
        }
        .panel-section {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
            border-right: 1px solid #ddd;
            padding-right: 5px;
            padding-left: 5px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }
        .panel-section:first-child {
            flex: 1;
            width: auto;
            padding-left: 0;
        }
        .panel-section:first-child h3 {
            text-align: left;
            padding-left: 15px;
            font-size: 13px;
        }
        .panel-section:nth-child(2) {
            width: 250px;
            flex: 0 0 250px;
        }
        .panel-section:last-child {
            margin-bottom: 0;
            padding-bottom: 0;
            border-right: none;
        }
        .panel-section h3 {
            text-align: left;
            padding-left: 10px;
            margin-top: 0;
            margin-bottom: 2px;
            font-size: 12px;
        }
        .controls-row {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 5px;
        }
        /* 修改摇杆控制样式以适应新面板 */
        /* 修改楼层控制部分的布局 */
        .panel-section:nth-child(3) .controls-row {
            display: grid;
            grid-template-columns: auto 1fr auto;
            grid-template-rows: auto auto;
            gap: 5px;
            align-items: center;
        }
        .panel-section:nth-child(3) .direction-controls {
            grid-column: 2;
            grid-row: 1 / span 2;
            justify-self: center;
            margin-left: 5px;
            margin-right: 5px;
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            gap: 5px;
        }
        .panel-section:nth-child(3) #resetBtn {
            grid-column: 3;
            grid-row: 1 / span 2;
            width: auto;
            height: auto;
            margin-top: 0;
            padding: 4px 6px;
            font-size: 11px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-left: 5px;
        }
        .panel-section:nth-child(3) h3 {
            margin-bottom: 10px;
        }
        #joystickTip {
            position: absolute;
            bottom: -20px;
            width: 100%;
            text-align: center;
            font-size: 12px;
            color: #666;
        }
        .panel-section:nth-child(3) .height-controls {
            grid-column: 1;
            grid-row: 1 / span 2;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
    </style>
    <!-- 引入 Babylon.js 库 -->
    <script src="babylon.js"></script>
    <script src="babylonjs.loaders.min.js"></script>
</head>
<body>
    <canvas id="renderCanvas"></canvas>
    
    <!-- 将场景旋转控制移到底部面板外 -->
    <!-- <div id="joystickRotationControl">
        <div id="joystickRotationTitle">场景旋转</div>
        <div id="joystickBase">
            <div id="joystickHandle"></div>
        </div>
        <div id="joystickTip">← 左右拖动控制旋转 →</div>
    </div> -->
    
    <div id="unifiedControlPanel">
        <div class="panel-section">
            <h3>楼层选择</h3>
            <div class="floor-buttons-row">
                <div class="floor-btn-container">
                    <button class="floor-btn" data-floor="1">楼层 1</button>
                    <div class="floor-btn-actions">
                        <button class="lock-btn" data-floor="1">锁定</button>
                        <button class="delete-btn" data-floor="1">删除</button>
                    </div>
                </div>
                <div class="floor-btn-container">
                    <button class="floor-btn" data-floor="2">楼层 2</button>
                    <div class="floor-btn-actions">
                        <button class="lock-btn" data-floor="2">锁定</button>
                        <button class="delete-btn" data-floor="2">删除</button>
                    </div>
                </div>
                <div class="floor-btn-container">
                    <button class="floor-btn" data-floor="3">楼层 3</button>
                    <div class="floor-btn-actions">
                        <button class="lock-btn" data-floor="3">锁定</button>
                        <button class="delete-btn" data-floor="3">删除</button>
                    </div>
                </div>
                <div class="floor-btn-container">
                    <button class="floor-btn" data-floor="4">楼层 4</button>
                    <div class="floor-btn-actions">
                        <button class="lock-btn" data-floor="4">锁定</button>
                        <button class="delete-btn" data-floor="4">删除</button>
                    </div>
                </div>
                <div class="floor-btn-container">
                    <button class="floor-btn" data-floor="5">楼层 5</button>
                    <div class="floor-btn-actions">
                        <button class="lock-btn" data-floor="5">锁定</button>
                        <button class="delete-btn" data-floor="5">删除</button>
                    </div>
                </div>
                <div class="floor-btn-container">
                    <button class="floor-btn" data-floor="6">楼层 6</button>
                    <div class="floor-btn-actions">
                        <button class="lock-btn" data-floor="6">锁定</button>
                        <button class="delete-btn" data-floor="6">删除</button>
                    </div>
                </div>
                <div class="floor-btn-container">
                    <button class="floor-btn" data-floor="7">楼层 7</button>
                    <div class="floor-btn-actions">
                        <button class="lock-btn" data-floor="7">锁定</button>
                        <button class="delete-btn" data-floor="7">删除</button>
                    </div>
                </div>
                <div class="floor-btn-container">
                    <button class="floor-btn" data-floor="8">楼层 8</button>
                    <div class="floor-btn-actions">
                        <button class="lock-btn" data-floor="8">锁定</button>
                        <button class="delete-btn" data-floor="8">删除</button>
                    </div>
                </div>
            </div>
        </div>
        
        <div id="joystickRotationControl">
            <div id="joystickRotationTitle">场景旋转</div>
            <div id="joystickBase">
                <div id="joystickHandle"></div>
            </div>
            <div id="joystickTip">← 左右拖动控制旋转 →</div>
        </div>
        
        <div class="panel-section">
            <h3>楼层控制</h3>
            <div class="controls-row">
                <div class="height-controls">
                    <button class="height-btn" id="moveUp">上移 ↑</button>
                    <button class="height-btn" id="moveDown">下移 ↓</button>
                </div>
                
                <div class="direction-controls">
                    <div></div>
                    <button class="direction-btn" id="moveForward">↑</button>
                    <div></div>
                    <button class="direction-btn" id="moveLeft">←</button>
                    <button class="direction-btn" id="moveBackward">↓</button>
                    <button class="direction-btn" id="moveRight">→</button>
                </div>
                
                <button id="resetBtn">重置位置</button>
            </div>
        </div>
    </div>

    <!-- 保留Y轴和缩放控制面板，因为它们在侧边 -->
    <div id="yAxisControl">
        <div id="yAxisLabel">高度</div>
        <div id="yAxisSlider">
            <div id="yAxisHandle"></div>
        </div>
    </div>

    <div id="zoomControl">
        <div id="zoomLabel">缩放</div>
        <div id="zoomSlider">
            <div id="zoomHandle"></div>
        </div>
    </div>

    <script>
        // 禁止双击缩放
        document.addEventListener('touchstart', function(event) {
            if (event.touches.length > 1) {
                event.preventDefault();
            }
        }, { passive: false });
        
        let lastTouchEnd = 0;
        document.addEventListener('touchend', function(event) {
            const now = Date.now();
            if (now - lastTouchEnd <= 300) {
                event.preventDefault();
            }
            lastTouchEnd = now;
        }, { passive: false });
        
        window.addEventListener('DOMContentLoaded', function() {
            // 获取画布元素
            const canvas = document.getElementById('renderCanvas');
            
            // 创建 Babylon 引擎
            const engine = new BABYLON.Engine(canvas, true);
            
            // 创建场景
            const createScene = function() {
                const scene = new BABYLON.Scene(engine);
                
                // 设置背景色
                scene.clearColor = new BABYLON.Color4(0.75, 0.85, 0.9, 1.0);
                
                // 创建相机
                const camera = new BABYLON.ArcRotateCamera("camera", -Math.PI/4, Math.PI*75/180, 10, new BABYLON.Vector3(0, 0.5, 0), scene);
                camera.attachControl(canvas, true);
                camera.lowerRadiusLimit = 0.5;
                camera.upperRadiusLimit = 10;
                
                // 设置相机初始位置
                camera.alpha = -Math.PI/4;
                camera.beta = Math.PI*75/180;
                camera.radius = 10;
                
                // 设置相机控制按钮
                camera.inputs.attached.pointers.buttons = [2]; // 只允许右键控制相机，左键用于拖动
                
                // 创建光源
                const light1 = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(1, 1, 0), scene);
                light1.intensity = 0.7;
                
                const light2 = new BABYLON.DirectionalLight("light2", new BABYLON.Vector3(-1, -1, -1), scene);
                light2.intensity = 0.5;
                
                // 创建光源容器，使光源不随相机旋转
                const lightParent = new BABYLON.TransformNode("lightParent", scene);
                light1.parent = lightParent;
                light2.parent = lightParent;
                
                // 确保光源不随相机旋转
                scene.onBeforeRenderObservable.add(() => {
                    // 重置光源容器的旋转，使其不受相机旋转影响
                    lightParent.rotation.y = -camera.alpha;
                });
                
                // 创建地面
                const ground = BABYLON.MeshBuilder.CreateGround("ground", {width: 5, height: 5}, scene);
                const groundMaterial = new BABYLON.StandardMaterial("groundMaterial", scene);
                groundMaterial.diffuseColor = new BABYLON.Color3(0.2, 0.2, 0.2);
                ground.material = groundMaterial;
                
                // 存储已加载的楼层
                const loadedFloors = {};
                
                // 存储已锁定的楼层
                const lockedFloors = {};
                
                // 当前选中的楼层 - 设置为全局变量
                window.selectedFloor = null;
                
                // 楼层的位置
                const floorPositions = [];
                
                // 基础高度偏移量
                const baseHeightOffset = 0; // 修改为0，不再使用偏移量
                
                // 预加载所有楼层模型
                function preloadAllFloors() {
                    // 获取所有楼层按钮
                    const floorButtons = document.querySelectorAll('.floor-btn');
                    const totalFloors = floorButtons.length;
                    let loadedCount = 0;
                    
                    console.log(`开始预加载 ${totalFloors} 个楼层...`);
                    
                    // 创建加载状态提示
                    const loadingStatus = document.createElement('div');
                    loadingStatus.style.position = 'absolute';
                    loadingStatus.style.top = '50%';
                    loadingStatus.style.left = '50%';
                    loadingStatus.style.transform = 'translate(-50%, -50%)';
                    loadingStatus.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
                    loadingStatus.style.color = 'white';
                    loadingStatus.style.padding = '20px';
                    loadingStatus.style.borderRadius = '10px';
                    loadingStatus.style.zIndex = '1000';
                    loadingStatus.style.textAlign = 'center';
                    loadingStatus.innerHTML = '正在加载楼层模型...<br>0%';
                    document.body.appendChild(loadingStatus);
                    
                    // 遍历所有楼层按钮，获取楼层编号并加载
                    floorButtons.forEach(button => {
                        const floorNumber = button.getAttribute('data-floor');
                        
                        // 加载OBJ模型
                        BABYLON.SceneLoader.ImportMesh("", "build/", `${floorNumber}.obj`, scene, function(meshes) {
                            // 创建一个父节点来包含所有的网格
                            const floorParent = new BABYLON.TransformNode(`floor${floorNumber}`, scene);
                            
                            // 将所有网格添加到父节点
                            meshes.forEach(mesh => {
                                if (mesh.id !== "__root__") {
                                    mesh.parent = floorParent;
                                }
                            });
                            
                            // 获取原始边界框（缩放前）
                            let minY = Infinity;
                            let maxY = -Infinity;
                            
                            meshes.forEach(mesh => {
                                if (mesh.id !== "__root__") {
                                    const boundingInfo = mesh.getBoundingInfo();
                                    minY = Math.min(minY, boundingInfo.boundingBox.minimumWorld.y);
                                    maxY = Math.max(maxY, boundingInfo.boundingBox.maximumWorld.y);
                                }
                            });
                            
                            const originalHeight = maxY - minY;
                            
                            // 将模型缩小到原来的3%
                            floorParent.scaling = new BABYLON.Vector3(0.01, 0.01, 0.01);
                            
                            // 计算缩放后的高度
                            const scaledHeight = originalHeight * 0.01;
                            
                            // 设置固定的Y轴位置为0
                            const yPosition = 0;
                            
                            // 设置楼层位置 - 修改为地面外部的位置
                            floorParent.position = new BABYLON.Vector3(2.5, yPosition, 2.5); // 设置在地面边缘外
                            
                            // 记录楼层位置和高度
                            floorPositions.push({
                                floor: floorNumber,
                                position: floorParent.position.clone(),
                                height: scaledHeight
                            });
                            
                            // 存储已加载的楼层
                            loadedFloors[floorNumber] = floorParent;
                            
                            // 设置为可拖动
                            makeFloorDraggable(floorParent);
                            
                            // 默认隐藏所有楼层
                            floorParent.setEnabled(false);
                            
                            // 不显示删除和锁定按钮，等待用户点击添加楼层时再显示
                            
                            // 更新加载计数和状态
                            loadedCount++;
                            const percentage = Math.round((loadedCount / totalFloors) * 100);
                            loadingStatus.innerHTML = `正在加载楼层模型...<br>${percentage}%`;
                            
                            console.log(`楼层 ${floorNumber} 已加载，进度: ${percentage}%`);
                            
                            // 检查是否所有楼层都已加载
                            if (loadedCount === totalFloors) {
                                console.log('所有楼层加载完成');
                                // 移除加载状态提示
                                setTimeout(() => {
                                    document.body.removeChild(loadingStatus);
                                }, 500);
                            }
                        });
                    });
                }
                
                // 添加楼层到场景
                function addFloorToScene(floorNumber) {
                    // 检查该楼层是否已经加载
                    if (!loadedFloors[floorNumber]) {
                        console.log(`楼层 ${floorNumber} 未加载`);
                        return;
                    }
                    
                    // 显示楼层
                    loadedFloors[floorNumber].setEnabled(true);
                    
                    // 设置为当前选中的楼层
                    window.selectedFloor = loadedFloors[floorNumber];
                    
                    // 显示对应的删除按钮和锁定按钮
                    const deleteBtn = document.querySelector(`.delete-btn[data-floor="${floorNumber}"]`);
                    const lockBtn = document.querySelector(`.lock-btn[data-floor="${floorNumber}"]`);
                    if (deleteBtn) {
                        deleteBtn.style.display = 'block';
                    }
                    if (lockBtn) {
                        lockBtn.style.display = 'block';
                    }
                    
                    console.log(`楼层 ${floorNumber} 已添加到场景`);
                }
                
                // 显示指定楼层（选中楼层）
                function selectFloor(floorNumber) {
                    // 检查该楼层是否已经加载
                    if (!loadedFloors[floorNumber]) {
                        console.log(`楼层 ${floorNumber} 未加载`);
                        return;
                    }
                    
                    // 检查楼层是否已启用
                    if (!loadedFloors[floorNumber].isEnabled()) {
                        // 如果楼层未启用，则添加到场景
                        addFloorToScene(floorNumber);
                    } else {
                        // 如果楼层已启用，则只选中它
                        window.selectedFloor = loadedFloors[floorNumber];
                    }
                    
                    console.log(`选中楼层 ${floorNumber}`);
                }
                
                // 删除楼层
                function removeFloor(floorNumber) {
                    const floor = loadedFloors[floorNumber];
                    if (!floor) return;
                    
                    // 如果当前选中的是要删除的楼层，则取消选中
                    if (window.selectedFloor === floor) {
                        window.selectedFloor = null;
                    }
                    
                    // 从场景中隐藏楼层，而不是完全销毁
                    floor.setEnabled(false);
                    
                    // 从已锁定楼层中移除
                    delete lockedFloors[floorNumber];
                    
                    // 隐藏对应的删除按钮和锁定按钮
                    const deleteBtn = document.querySelector(`.delete-btn[data-floor="${floorNumber}"]`);
                    const lockBtn = document.querySelector(`.lock-btn[data-floor="${floorNumber}"]`);
                    if (deleteBtn) {
                        deleteBtn.style.display = 'none';
                    }
                    if (lockBtn) {
                        lockBtn.style.display = 'none';
                        lockBtn.classList.remove('locked');
                        lockBtn.textContent = '锁定';
                    }
                    
                    console.log(`楼层 ${floorNumber} 已删除`);
                }
                
                // 锁定/解锁楼层
                function toggleLockFloor(floorNumber) {
                    const floor = loadedFloors[floorNumber];
                    if (!floor) return;
                    
                    const lockBtn = document.querySelector(`.lock-btn[data-floor="${floorNumber}"]`);
                    
                    if (lockedFloors[floorNumber]) {
                        // 解锁楼层
                        delete lockedFloors[floorNumber];
                        
                        // 重新添加拖动行为
                        makeFloorDraggable(floor);
                        
                        // 更新锁定按钮样式
                        if (lockBtn) {
                            lockBtn.classList.remove('locked');
                            lockBtn.textContent = '锁定';
                        }
                        
                        console.log(`楼层 ${floorNumber} 已解锁`);
                    } else {
                        // 锁定楼层
                        lockedFloors[floorNumber] = true;
                        
                        // 移除拖动行为
                        const behaviors = floor.behaviors;
                        if (behaviors && behaviors.length > 0) {
                            for (let i = 0; i < behaviors.length; i++) {
                                if (behaviors[i] instanceof BABYLON.PointerDragBehavior) {
                                    floor.removeBehavior(behaviors[i]);
                                    break;
                                }
                            }
                        }
                        
                        // 更新锁定按钮样式
                        if (lockBtn) {
                            lockBtn.classList.add('locked');
                            lockBtn.textContent = '解锁';
                        }
                        
                        console.log(`楼层 ${floorNumber} 已锁定`);
                    }
                }
                
                // 使楼层可拖动
                function makeFloorDraggable(floor) {
                    // 检查是否已锁定
                    const floorNumber = floor.name.replace('floor', '');
                    if (lockedFloors[floorNumber]) {
                        return; // 如果已锁定，则不添加拖动行为
                    }
                    
                    // 移除现有的拖动行为（如果有）
                    const behaviors = floor.behaviors;
                    if (behaviors && behaviors.length > 0) {
                        for (let i = 0; i < behaviors.length; i++) {
                            if (behaviors[i] instanceof BABYLON.PointerDragBehavior) {
                                floor.removeBehavior(behaviors[i]);
                                break;
                            }
                        }
                    }
                    
                    // 使用Babylon内置的拖动行为 - 移除dragPlaneNormal参数，允许在所有方向拖动
                    const pointerDragBehavior = new BABYLON.PointerDragBehavior({
                        // 不再限制在水平面上
                    });
                    
                    // 允许在所有方向拖动，包括Y轴
                    pointerDragBehavior.updateDragPlane = true;
                    
                    // 记录上一次有效的位置
                    let lastValidPosition = floor.position.clone();
                    
                    // 拖动开始事件
                    pointerDragBehavior.onDragStartObservable.add(() => {
                        window.selectedFloor = floor;
                        // 记录开始拖动时的有效位置
                        lastValidPosition = floor.position.clone();
                    });
                    
                    // 拖动事件
                    pointerDragBehavior.onDragObservable.add(() => {
                        // 检查Y轴位置是否小于0
                        if (floor.position.y < 0) {
                            // 如果低于地面，则将Y轴位置设置为0，保持XZ位置不变
                            floor.position.y = 0;
                            // 更新最后有效位置
                            lastValidPosition = floor.position.clone();
                        } else {
                            // 如果位置有效，更新最后有效位置
                            lastValidPosition = floor.position.clone();
                        }
                    });
                    
                    // 拖动结束事件
                    pointerDragBehavior.onDragEndObservable.add(() => {
                        // 最终检查确保不低于地面
                        if (floor.position.y < 0) {
                            floor.position.y = 0;
                        }
                    });
                    
                    // 将拖动行为添加到楼层
                    floor.addBehavior(pointerDragBehavior);
                    
                    // 点击选择楼层 - 移除高亮效果
                    floor.getChildMeshes().forEach(mesh => {
                        mesh.isPickable = true;
                        
                        mesh.actionManager = new BABYLON.ActionManager(scene);
                        mesh.actionManager.registerAction(
                            new BABYLON.ExecuteCodeAction(
                                BABYLON.ActionManager.OnPickTrigger,
                                function() {
                                    window.selectedFloor = floor;
                                }
                            )
                        );
                    });
                }
                
                // 添加高度和方向控制
                function setupHeightControls() {
                    const moveUpBtn = document.getElementById('moveUp');
                    const moveDownBtn = document.getElementById('moveDown');
                    const moveForwardBtn = document.getElementById('moveForward');
                    const moveBackwardBtn = document.getElementById('moveBackward');
                    const moveLeftBtn = document.getElementById('moveLeft');
                    const moveRightBtn = document.getElementById('moveRight');
                    const resetBtn = document.getElementById('resetBtn');
                    
                    const heightStep = 0.03; // 高度步长
                    const moveStep = 0.05; // 水平移动步长
                    
                    // 上下移动控制
                    moveUpBtn.addEventListener('click', function() {
                        if (window.selectedFloor) {
                            window.selectedFloor.position.y += heightStep;
                        }
                    });
                    
                    moveDownBtn.addEventListener('click', function() {
                        if (window.selectedFloor) {
                            // 确保Y轴位置不小于0
                            window.selectedFloor.position.y = Math.max(0, window.selectedFloor.position.y - heightStep);
                        }
                    });
                    
                    // 获取相机视角下的方向向量
                    function getCameraDirectionVectors(camera) {
                        // 获取相机前方向量（z轴负方向）
                        const forward = new BABYLON.Vector3(0, 0, 1);
                        const forwardWorld = BABYLON.Vector3.TransformNormal(forward, camera.getWorldMatrix());
                        forwardWorld.y = 0; // 保持在水平面上移动
                        forwardWorld.normalize();
                        
                        // 获取相机右方向量（x轴正方向）
                        const right = new BABYLON.Vector3(1, 0, 0);
                        const rightWorld = BABYLON.Vector3.TransformNormal(right, camera.getWorldMatrix());
                        rightWorld.y = 0; // 保持在水平面上移动
                        rightWorld.normalize();
                        
                        return {
                            forward: forwardWorld,
                            right: rightWorld
                        };
                    }
                    
                    // 前后左右移动控制 - 基于相机视角
                    moveForwardBtn.addEventListener('click', function() {
                        if (window.selectedFloor) {
                            const directions = getCameraDirectionVectors(camera);
                            window.selectedFloor.position.addInPlace(directions.forward.scale(moveStep));
                        }
                    });
                    
                    moveBackwardBtn.addEventListener('click', function() {
                        if (window.selectedFloor) {
                            const directions = getCameraDirectionVectors(camera);
                            window.selectedFloor.position.subtractInPlace(directions.forward.scale(moveStep));
                        }
                    });
                    
                    moveLeftBtn.addEventListener('click', function() {
                        if (window.selectedFloor) {
                            const directions = getCameraDirectionVectors(camera);
                            window.selectedFloor.position.subtractInPlace(directions.right.scale(moveStep));
                        }
                    });
                    
                    moveRightBtn.addEventListener('click', function() {
                        if (window.selectedFloor) {
                            const directions = getCameraDirectionVectors(camera);
                            window.selectedFloor.position.addInPlace(directions.right.scale(moveStep));
                        }
                    });
                    
                    resetBtn.addEventListener('click', function() {
                        if (window.selectedFloor) {
                            const floorNumber = window.selectedFloor.name.replace('floor', '');
                            const floorData = floorPositions.find(fp => fp.floor === floorNumber);
                            
                            if (floorData) {
                                window.selectedFloor.position = floorData.position.clone();
                            }
                        }
                    });
                    
                    // 添加键盘控制 - 同样基于相机视角
                    window.addEventListener('keydown', function(e) {
                        if (window.selectedFloor) {
                            const directions = getCameraDirectionVectors(camera);
                            
                            switch(e.key) {
                                case 'ArrowUp':
                                    window.selectedFloor.position.y += heightStep;
                                    e.preventDefault();
                                    break;
                                case 'ArrowDown':
                                    window.selectedFloor.position.y = Math.max(0, window.selectedFloor.position.y - heightStep);
                                    e.preventDefault();
                                    break;
                                case 'w': // 前进
                                    window.selectedFloor.position.addInPlace(directions.forward.scale(moveStep));
                                    e.preventDefault();
                                    break;
                                case 's': // 后退
                                    window.selectedFloor.position.subtractInPlace(directions.forward.scale(moveStep));
                                    e.preventDefault();
                                    break;
                                case 'a': // 左移
                                    window.selectedFloor.position.subtractInPlace(directions.right.scale(moveStep));
                                    e.preventDefault();
                                    break;
                                case 'd': // 右移
                                    window.selectedFloor.position.addInPlace(directions.right.scale(moveStep));
                                    e.preventDefault();
                                    break;
                            }
                        }
                    });
                }
                
                // 添加楼层按钮事件监听
                const floorButtons = document.querySelectorAll('.floor-btn');
                floorButtons.forEach(button => {
                    button.addEventListener('click', function() {
                        const floorNumber = this.getAttribute('data-floor');
                        selectFloor(floorNumber);
                        
                        // 移除其他按钮的active类
                        floorButtons.forEach(btn => {
                            btn.classList.remove('active');
                        });
                        
                        // 添加active类到当前按钮
                        this.classList.add('active');
                    });
                });
                
                // 添加删除按钮事件监听
                const deleteButtons = document.querySelectorAll('.delete-btn');
                deleteButtons.forEach(button => {
                    button.addEventListener('click', function() {
                        const floorNumber = this.getAttribute('data-floor');
                        removeFloor(floorNumber);
                    });
                });
                
                // 添加锁定按钮事件监听
                const lockButtons = document.querySelectorAll('.lock-btn');
                lockButtons.forEach(button => {
                    button.addEventListener('click', function() {
                        const floorNumber = this.getAttribute('data-floor');
                        toggleLockFloor(floorNumber);
                    });
                });
                
                // 设置高度控制
                setupHeightControls();
                
                // 设置摇杆式旋转控制
                setupJoystickRotationControl(camera);
                
                // 设置Y轴移动和缩放控制
                setupTouchControls(camera);
                
                // 预加载所有楼层
                preloadAllFloors();
                
                return scene;
            };
            
            // 设置摇杆式旋转控制
            function setupJoystickRotationControl(camera) {
                const joystickControl = document.getElementById('joystickRotationControl');
                const joystickBase = document.getElementById('joystickBase');
                const joystickHandle = document.getElementById('joystickHandle');
                
                // 摇杆控制变量
                let isDragging = false;
                let centerX = 0;
                let centerY = 0;
                let maxDistance = 0;
                let currentRotation = camera.alpha;
                let startRotation = 0;
                let isAnimating = false;
                let continuousRotation = false;
                let rotationSpeed = 0;
                let rotationDirection = 0;
                let lastFrameTime = 0;
                
                // 初始化摇杆中心点和最大距离
                function initJoystick() {
                    const rect = joystickBase.getBoundingClientRect();
                    centerX = rect.width / 2;
                    centerY = rect.height / 2;
                    // 调整最大距离，使滑块不会超出边界
                    maxDistance = (rect.width / 2) - (joystickHandle.offsetWidth / 2) - 2;
                    
                    // 将手柄放置在中心位置
                    updateHandlePosition(centerX, centerY);
                }
                
                // 更新手柄位置的辅助函数
                function updateHandlePosition(x, y) {
                    joystickHandle.style.left = `${x}px`;
                    joystickHandle.style.top = `${y}px`;
                    joystickHandle.style.transform = 'translate(-50%, -50%)';
                }
                
                // 初始化摇杆
                initJoystick();
                window.addEventListener('resize', initJoystick);
                
                // 添加视觉反馈
                joystickHandle.addEventListener('mouseenter', function() {
                    this.style.backgroundColor = '#8E24AA';
                });
                
                joystickHandle.addEventListener('mouseleave', function() {
                    if (!isDragging) {
                        this.style.backgroundColor = '#9C27B0';
                    }
                });
                
                // 摇杆事件监听
                joystickBase.addEventListener('mousedown', startDrag);
                joystickBase.addEventListener('touchstart', startDrag, { passive: false });
                
                window.addEventListener('mousemove', moveDrag);
                window.addEventListener('touchmove', moveDrag, { passive: false });
                
                window.addEventListener('mouseup', endDrag);
                window.addEventListener('touchend', endDrag);
                
                // 开始拖动
                function startDrag(e) {
                    isDragging = true;
                    startRotation = camera.alpha;
                    
                    // 添加视觉反馈
                    joystickHandle.style.backgroundColor = '#7B1FA2';
                    joystickHandle.style.boxShadow = '0 0 8px rgba(0, 0, 0, 0.5)';
                    
                    // 如果点击的是基座而不是手柄，立即移动手柄到点击位置
                    if (e.target === joystickBase) {
                        const clientX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
                        moveDrag(e);
                    }
                    
                    if (e.preventDefault) {
                        e.preventDefault();
                    }
                }
                
                // 拖动中
                function moveDrag(e) {
                    if (!isDragging) return;
                    
                    // 获取触摸/鼠标位置
                    const clientX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
                    const clientY = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;
                    
                    // 计算相对于摇杆基座的位置
                    const rect = joystickBase.getBoundingClientRect();
                    const relX = clientX - rect.left;
                    const relY = clientY - rect.top;
                    
                    // 计算与中心的距离和角度
                    const deltaX = relX - centerX;
                    const deltaY = relY - centerY;
                    
                    // 对于长条形摇杆，主要关注水平方向的移动
                    const distance = Math.min(Math.abs(deltaX), maxDistance);
                    const direction = Math.sign(deltaX);
                    
                    // 计算手柄的新位置 - 只在水平方向移动
                    const newX = centerX + distance * direction;
                    const newY = centerY; // 保持垂直位置不变
                    
                    // 更新手柄位置
                    updateHandlePosition(newX, newY);
                    
                    // 根据摇杆位置计算旋转角度和速度
                    const speedFactor = 0.015; // 调整旋转速度因子
                    rotationSpeed = (distance / maxDistance) * speedFactor * Math.PI;
                    rotationDirection = -direction; // 负方向表示向左旋转
                    
                    // 设置连续旋转标志 - 只要摇杆偏离中心就启用连续旋转
                    continuousRotation = distance > 0;
                    
                    if (e.preventDefault) {
                        e.preventDefault();
                    }
                }
                
                // 结束拖动
                function endDrag() {
                    if (!isDragging) return;
                    
                    isDragging = false;
                    continuousRotation = false;
                    rotationSpeed = 0;
                    
                    // 恢复视觉样式
                    joystickHandle.style.backgroundColor = '#9C27B0';
                    joystickHandle.style.boxShadow = '0 0 5px rgba(0, 0, 0, 0.3)';
                    
                    // 动画将手柄返回中心位置
                    animateHandleToCenter();
                }
                
                // 动画将手柄返回中心位置
                function animateHandleToCenter() {
                    if (isAnimating) return;
                    
                    isAnimating = true;
                    
                    // 获取当前手柄位置
                    const handleRect = joystickHandle.getBoundingClientRect();
                    const baseRect = joystickBase.getBoundingClientRect();
                    const currentX = handleRect.left - baseRect.left + joystickHandle.offsetWidth / 2;
                    const currentY = handleRect.top - baseRect.top + joystickHandle.offsetHeight / 2;
                    
                    // 计算到中心的距离
                    const deltaX = centerX - currentX;
                    const deltaY = centerY - currentY;
                    
                    // 使用requestAnimationFrame实现平滑动画
                    const startTime = performance.now();
                    const duration = 300; // 动画持续时间（毫秒）
                    
                    function animate(time) {
                        const elapsed = time - startTime;
                        const progress = Math.min(elapsed / duration, 1);
                        
                        // 使用缓动函数使动画更平滑
                        const easeProgress = 1 - Math.pow(1 - progress, 3); // 缓出
                        
                        // 计算新位置
                        const newX = currentX + deltaX * easeProgress;
                        const newY = currentY + deltaY * easeProgress;
                        
                        // 更新手柄位置
                        updateHandlePosition(newX, newY);
                        
                        if (progress < 1) {
                            requestAnimationFrame(animate);
                        } else {
                            isAnimating = false;
                        }
                    }
                    
                    requestAnimationFrame(animate);
                }
                
                // 连续旋转更新函数
                function updateContinuousRotation(time) {
                    if (continuousRotation) {
                        // 计算时间差，确保旋转速度与帧率无关
                        const deltaTime = lastFrameTime ? (time - lastFrameTime) / 1000 : 0.016;
                        
                        // 更新相机旋转 - 旋转速度与摇杆偏移成正比
                        camera.alpha += rotationDirection * rotationSpeed * deltaTime * 60;
                    }
                    
                    lastFrameTime = time;
                    requestAnimationFrame(updateContinuousRotation);
                }
                
                // 启动连续旋转更新循环
                requestAnimationFrame(updateContinuousRotation);
            }
            
            // 设置触摸控制
            function setupTouchControls(camera) {
                // Y轴移动控制
                const yAxisControl = document.getElementById('yAxisControl');
                const yAxisSlider = document.getElementById('yAxisSlider');
                const yAxisHandle = document.getElementById('yAxisHandle');
                
                // 缩放控制
                const zoomControl = document.getElementById('zoomControl');
                const zoomSlider = document.getElementById('zoomSlider');
                const zoomHandle = document.getElementById('zoomHandle');
                
                // Y轴控制变量
                let isDraggingY = false;
                let startYPosition = 0;
                let startTargetY = 0;
                
                // 缩放控制变量
                let isDraggingZoom = false;
                let startZoomPosition = 0;
                let startRadius = 0;
                
                // Y轴控制事件
                yAxisSlider.addEventListener('mousedown', startYDrag);
                yAxisSlider.addEventListener('touchstart', startYDrag, { passive: false });
                
                window.addEventListener('mousemove', moveYDrag);
                window.addEventListener('touchmove', moveYDrag, { passive: false });
                
                window.addEventListener('mouseup', endYDrag);
                window.addEventListener('touchend', endYDrag);
                
                // 缩放控制事件
                zoomSlider.addEventListener('mousedown', startZoomDrag);
                zoomSlider.addEventListener('touchstart', startZoomDrag, { passive: false });
                
                window.addEventListener('mousemove', moveZoomDrag);
                window.addEventListener('touchmove', moveZoomDrag, { passive: false });
                
                window.addEventListener('mouseup', endZoomDrag);
                window.addEventListener('touchend', endZoomDrag);
                
                // Y轴控制函数
                function startYDrag(e) {
                    isDraggingY = true;
                    startYPosition = getYPosition(e);
                    startTargetY = camera.target.y;
                    
                    // 立即更新滑块位置，确保初始拖动时位置正确
                    moveYDrag(e);
                    
                    if (e.preventDefault) {
                        e.preventDefault();
                    }
                }
                
                function moveYDrag(e) {
                    if (!isDraggingY) return;
                    
                    const currentY = getYPosition(e);
                    const deltaY = (startYPosition - currentY) / 100; // 调整灵敏度
                    
                    // 获取滑动区域的边界
                    const sliderRect = yAxisSlider.getBoundingClientRect();
                    const handleHeight = yAxisHandle.offsetHeight;
                    
                    // 计算滑块可移动的Y坐标范围
                    const minHandleY = sliderRect.top;
                    const maxHandleY = sliderRect.bottom - handleHeight;
                    
                    // 获取当前鼠标/触摸的Y坐标，并限制在可移动范围内
                    const touchY = Math.min(maxHandleY, Math.max(minHandleY, currentY - handleHeight / 2));
                    
                    // 计算相对于滑动区域的位置百分比
                    const sliderHeight = sliderRect.height - handleHeight;
                    const positionPercent = 1 - ((touchY - minHandleY) / sliderHeight);
                    
                    // 根据百分比计算相机目标的Y坐标
                    const minY = 0; // 最小Y值（地面高度）
                    const maxY = 2;  // 最大Y值
                    camera.target.y = minY + (positionPercent * (maxY - minY));
                    
                    // 更新滑块位置
                    updateYAxisHandlePosition();
                    
                    if (e.preventDefault) {
                        e.preventDefault();
                    }
                }
                
                function endYDrag() {
                    isDraggingY = false;
                }
                
                // 缩放控制函数
                function startZoomDrag(e) {
                    isDraggingZoom = true;
                    startZoomPosition = getYPosition(e);
                    startRadius = camera.radius;
                    
                    // 立即更新滑块位置，确保初始拖动时位置正确
                    moveZoomDrag(e);
                    
                    if (e.preventDefault) {
                        e.preventDefault();
                    }
                }
                
                function moveZoomDrag(e) {
                    if (!isDraggingZoom) return;
                    
                    const currentY = getYPosition(e);
                    
                    // 获取滑动区域的边界
                    const sliderRect = zoomSlider.getBoundingClientRect();
                    const handleHeight = zoomHandle.offsetHeight;
                    
                    // 计算滑块可移动的Y坐标范围
                    const minHandleY = sliderRect.top;
                    const maxHandleY = sliderRect.bottom - handleHeight;
                    
                    // 获取当前鼠标/触摸的Y坐标，并限制在可移动范围内
                    const touchY = Math.min(maxHandleY, Math.max(minHandleY, currentY - handleHeight / 2));
                    
                    // 计算相对于滑动区域的位置百分比
                    const sliderHeight = sliderRect.height - handleHeight;
                    const positionPercent = 1 - ((touchY - minHandleY) / sliderHeight);
                    
                    // 根据百分比计算相机半径
                    camera.radius = camera.lowerRadiusLimit + (positionPercent * (camera.upperRadiusLimit - camera.lowerRadiusLimit));
                    
                    // 更新滑块位置
                    updateZoomHandlePosition();
                    
                    if (e.preventDefault) {
                        e.preventDefault();
                    }
                }
                
                function endZoomDrag() {
                    isDraggingZoom = false;
                }
                
                // 辅助函数：获取Y坐标
                function getYPosition(e) {
                    return e.type.includes('touch') ? e.touches[0].clientY : e.clientY;
                }
                
                // 更新Y轴滑块位置
                function updateYAxisHandlePosition() {
                    // 计算滑块位置百分比（基于相机目标Y值的范围）
                    // 修改最小Y值为0，确保不低于地面
                    const minY = 0; // 最小Y值（地面高度）
                    const maxY = 2;  // 最大Y值
                    const percent = Math.min(1, Math.max(0, (camera.target.y - minY) / (maxY - minY)));
                    const sliderHeight = yAxisSlider.clientHeight - yAxisHandle.clientHeight;
                    const newTop = Math.min(sliderHeight, Math.max(0, (1 - percent) * sliderHeight));
                    
                    // 更新滑块位置
                    yAxisHandle.style.top = `${newTop}px`;
                }
                
                // 更新缩放滑块位置
                function updateZoomHandlePosition() {
                    // 计算滑块位置百分比（基于相机半径的范围）
                    const percent = Math.min(1, Math.max(0, (camera.radius - camera.lowerRadiusLimit) / (camera.upperRadiusLimit - camera.lowerRadiusLimit)));
                    const sliderHeight = zoomSlider.clientHeight - zoomHandle.clientHeight;
                    const newTop = Math.min(sliderHeight, Math.max(0, (1 - percent) * sliderHeight));
                    
                    // 更新滑块位置
                    zoomHandle.style.top = `${newTop}px`;
                }
                
                // 初始化滑块位置
                // 确保Y轴滑块初始位置与相机目标Y轴位置(0.5)同步
                function initYAxisHandlePosition() {
                    const minY = 0;
                    const maxY = 2;
                    const initialY = 0.5; // 与相机初始Y轴位置同步
                    const percent = (initialY - minY) / (maxY - minY);
                    const sliderHeight = yAxisSlider.clientHeight - yAxisHandle.clientHeight;
                    const newTop = (1 - percent) * sliderHeight;
                    yAxisHandle.style.top = `${newTop}px`;
                }
                
                // 先设置初始位置，然后再添加更新函数
                initYAxisHandlePosition();
                updateZoomHandlePosition();
            }
            
            // 创建场景
            const scene = createScene();
            
            // 运行渲染循环
            engine.runRenderLoop(function() {
                scene.render();
            });
            
            // 监听窗口大小变化
            window.addEventListener('resize', function() {
                engine.resize();
            });
        });
    </script>
</body>
</html>
